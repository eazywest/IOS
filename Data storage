import Foundation

protocol JSONSerializable: Encodable {}
protocol JSONDeserializable: Decodable {}
typealias JSONCodable = JSONSerializable & JSONDeserializable

struct Request<T: JSONCodable> {
    let data: T
    let requestID: String

    init(data: T, requestID: String = UUID().uuidString) {
        self.data = data
        self.requestID = requestID
    }
}

protocol RequestStorable {
    associatedtype RequestType: JSONCodable
    func saveRequest(request: Request<RequestType>, completion: @escaping (Result<Void, Error>) -> Void)
    func loadRequest(requestID: String, completion: @escaping (Result<Request<RequestType>?, Error>) -> Void)
    func clearRequest(requestID: String, completion: @escaping (Result<Void, Error>) -> Void)
}

class RequestStorage<T: JSONCodable>: RequestStorable {
    typealias RequestType = T

    func saveRequest(request: Request<RequestType>, completion: @escaping (Result<Void, Error>) -> Void) {
        let encoder = JSONEncoder()
        DispatchQueue.global(qos: .background).async {
            do {
                let encodedData = try encoder.encode(request)
                UserDefaults.standard.set(encodedData, forKey: request.requestID)
                DispatchQueue.main.async {
                    print("Request saved successfully with ID: \(request.requestID)")
                    completion(.success(()))
                }
            } catch {
                DispatchQueue.main.async {
                    print("Failed to encode request: \(error)")
                    completion(.failure(error))
                }
            }
        }
    }

    func loadRequest(requestID: String, completion: @escaping (Result<Request<RequestType>?, Error>) -> Void) {
        DispatchQueue.global(qos: .background).async {
            guard let data = UserDefaults.standard.data(forKey: requestID) else {
                DispatchQueue.main.async {
                    print("No request found with ID: \(requestID)")
                    completion(.success(nil))
                }
                return
            }

            let decoder = JSONDecoder()
            do {
                let decodedRequest = try decoder.decode(Request<RequestType>.self, from: data)
                DispatchQueue.main.async {
                    print("Request loaded successfully with ID: \(requestID)")
                    completion(.success(decodedRequest))
                }
            } catch {
                DispatchQueue.main.async {
                    print("Failed to decode request: \(error)")
                    completion(.failure(error))
                }
            }
        }
    }

    func clearRequest(requestID: String, completion: @escaping (Result<Void, Error>) -> Void) {
        DispatchQueue.global(qos: .background).async {
            UserDefaults.standard.removeObject(forKey: requestID)
            DispatchQueue.main.async {
                print("Request cleared with ID: \(requestID)")
                completion(.success(()))
            }
        }
    }
}

struct UserProfile: JSONCodable {
    let id: Int
    let name: String
    let email: String
}

let requestStorage = RequestStorage<UserProfile>()

let newUserProfile = UserProfile(id: 1, name: "Bob", email: "Bob@example.com")
let userRequest = Request(data: newUserProfile)


requestStorage.saveRequest(request: userRequest) { result in
    switch result {
    case .success:
        requestStorage.loadRequest(requestID: userRequest.requestID) { loadResult in
            switch loadResult {
            case .success(let loadedRequest):
                if let loadedRequest = loadedRequest {
                    print("Loaded Request: \(loadedRequest.data)")
                    requestStorage.clearRequest(requestID: userRequest.requestID) { clearResult in
                        switch clearResult {
                        case .success:
                            break 
                        case .failure(let error):
                            print("Failed to clear request: \(error)")
                        }
                    }
                } else {
                    print("No data loaded")
                }
            case .failure(let error):
                print("Failed to load request: \(error)")
            }
        }
    case .failure(let error):
        print("Failed to save request: \(error)")
    }
}


RunLoop.main.run(until: Date(timeIntervalSinceNow: 2))
